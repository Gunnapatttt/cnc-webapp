function doGet() {
  return HtmlService.createHtmlOutputFromFile('Index');
}

function submitLog(data) {
  console.log("submitLog called with data:", data);
  
  const SHEET_NAME = "CNC LOG";
  const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(SHEET_NAME);
  if (!sheet) {
    console.error("Sheet 'CNC LOG' not found");
    throw new Error("Sheet 'CNC LOG' not found");
  }

  const values = sheet.getDataRange().getValues();
  const logNo = values.length; // 1-based, header is row 1
  console.log("Current sheet has", logNo, "rows");

  // Check if this is a START form submission (has machineNo but no fg/ng/rework)
  if (data.machineNo && !data.fg && !data.ng && !data.rework) {
    console.log("Processing START form submission");
    // Always append a new row for START form
    const row = [
      logNo, // Log No.
      data.projectNo || "",
      data.customerName || "",
      data.partName || "",
      "'" + (data.drawingNo || ""),
      data.quantityOrdered || "",
      data.processNo || "",
      data.processName || "",
      data.stepNo || "",
      data.machineNo || "",
      data.employeeCode || "",
      new Date(), // Start Time
      "", // End Time
      "", // Cycle Time
      "", // FG
      "", // NG
      "", // Rework
      "OPEN"
    ];
    console.log("Appending row:", row);
    sheet.appendRow(row);
    console.log("Row appended successfully");
    formatLastRow();
    return;
  }

  // For STOP form submission, find and update the matching OPEN row
  if (data.fg !== undefined || data.ng !== undefined || data.rework !== undefined) {
    let found = false;
    for (let i = values.length - 1; i > 0; i--) {
      const row = values[i];
      console.log(
        "Comparing row:",
        {
          projectNo: [normalize(row[1]), normalize(data.projectNo)],
          customerName: [normalize(row[2]), normalize(data.customerName)],
          partName: [normalize(row[3]), normalize(data.partName)],
          drawingNo: [normalize(row[4]), normalize(data.drawingNo)],
          quantityOrdered: [normalize(row[5]), normalize(data.quantityOrdered)],
          processNo: [normalize(row[6]), normalize(data.processNo)],
          processName: [normalize(row[7]), normalize(data.processName)],
          stepNo: [normalize(row[8]), normalize(data.stepNo)],
          status: row[17]
        }
      );
      if (
        normalize(row[1]) == normalize(data.projectNo) &&
        normalize(row[2]) == normalize(data.customerName) &&
        normalize(row[3]) == normalize(data.partName) &&
        normalize(row[4]) == normalize(data.drawingNo) &&
        normalize(row[5]) == normalize(data.quantityOrdered) &&
        normalize(row[6]) == normalize(data.processNo) &&
        normalize(row[7]) == normalize(data.processName) &&
        normalize(row[8]) == normalize(data.stepNo) &&
        row[17] == "OPEN"
      ) {
        // Update this row
        const startTime = row[11] ? new Date(row[11]) : new Date();
        const endTime = new Date();
        const cycleTime = calculateWorkingTime(startTime, endTime);

        // Update columns: End Time (13), Cycle Time (14), FG (15), NG (16), Rework (17), Status (18)
        sheet.getRange(i + 1, 13).setValue(endTime); // End Time
        sheet.getRange(i + 1, 14).setValue(cycleTime); // Cycle Time
        sheet.getRange(i + 1, 15).setValue(data.fg || ""); // FG
        sheet.getRange(i + 1, 16).setValue(data.ng || ""); // NG
        sheet.getRange(i + 1, 17).setValue(data.rework || ""); // Rework
        sheet.getRange(i + 1, 18).setValue("CLOSE"); // Status
        formatLastRow();
        found = true;
        return;
      }
    }
    // If not found, check which fields did not match for the most recent OPEN row
    let lastOpenRow = null;
    for (let i = values.length - 1; i > 0; i--) {
      if (values[i][17] == "OPEN") {
        lastOpenRow = values[i];
        break;
      }
    }
    if (!lastOpenRow) {
      throw new Error("No OPEN job found in the log to close.");
    }
    let mismatches = [];
    if (normalize(lastOpenRow[1]) != normalize(data.projectNo)) mismatches.push("Project No.");
    if (normalize(lastOpenRow[2]) != normalize(data.customerName)) mismatches.push("Customer Name");
    if (normalize(lastOpenRow[3]) != normalize(data.partName)) mismatches.push("Part Name");
    if (normalize(lastOpenRow[4]) != normalize(data.drawingNo)) mismatches.push("Drawing No.");
    if (normalize(lastOpenRow[5]) != normalize(data.quantityOrdered)) mismatches.push("Quantity Ordered");
    if (normalize(lastOpenRow[6]) != normalize(data.processNo)) mismatches.push("Process No.");
    if (normalize(lastOpenRow[7]) != normalize(data.processName)) mismatches.push("Process Name");
    if (normalize(lastOpenRow[8]) != normalize(data.stepNo)) mismatches.push("Step No.");
    if (lastOpenRow[17] != "OPEN") mismatches.push("Status is not OPEN");

    throw new Error("No matching OPEN job found to close. Mismatched fields: " + mismatches.join(", "));
  }
}

function doPost(e) {
  var data = {};
  try {
    data = JSON.parse(e.postData.contents);
  } catch (err) {
    return ContentService.createTextOutput("Invalid JSON")
      .setMimeType(ContentService.MimeType.TEXT)
      .setHeader("Access-Control-Allow-Origin", "*");
  }
  try {
    submitLog(data);
    return ContentService.createTextOutput("OK")
      .setMimeType(ContentService.MimeType.TEXT)
      .setHeader("Access-Control-Allow-Origin", "*");
  } catch (err) {
    return ContentService.createTextOutput("ERROR: " + err.message)
      .setMimeType(ContentService.MimeType.TEXT)
      .setHeader("Access-Control-Allow-Origin", "*");
  }
}

// Add borders and color to the last row based on status
function formatLastRow() {
  var sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName("CNC LOG");
  var lastRow = sheet.getLastRow();
  var lastCol = sheet.getLastColumn();

  // Add borders to the last row
  sheet.getRange(lastRow, 1, 1, lastCol).setBorder(true, true, true, true, true, true);

  // Get the value of the Status column (assumed to be column 18)
  var statusCell = sheet.getRange(lastRow, 18);
  var status = statusCell.getValue();

  // Set background color based on status (only the status cell)
  if (status === "OPEN") {
    statusCell.setBackground("#FFF59D"); // Yellow
  } else if (status === "CLOSE") {
    statusCell.setBackground("#A5D6A7"); // Green
  } else {
    statusCell.setBackground(null); // Default
  }
}

function fixDrawingNoColumn() {
  var sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName("CNC LOG");
  var data = sheet.getDataRange().getValues();
  for (var i = 1; i < data.length; i++) { // skip header
    var cell = data[i][4]; // Drawing No. is column 5 (index 4)
    if (cell instanceof Date) {
      // Convert date to d/m format
      var asString = cell.getDate() + '/' + (cell.getMonth() + 1);
      // Write back as a string with a leading single quote
      sheet.getRange(i + 1, 5).setValue("'" + asString);
    }
  }
}

// Helper: Calculate working time between two dates, only counting working hours
function calculateWorkingTime(start, end) {
  // Working hours: Mon-Sat, 08:30–12:00 and 13:00–16:45
  const WORK_START = { h: 8, m: 30 };
  const LUNCH_START = { h: 12, m: 0 };
  const LUNCH_END = { h: 13, m: 0 };
  const WORK_END = { h: 16, m: 45 };

  let totalMs = 0;
  let current = new Date(start);

  while (current < end) {
    if (isWorkingDay(current)) {
      // Morning session
      let morningStart = setTime(current, WORK_START.h, WORK_START.m);
      let morningEnd = setTime(current, LUNCH_START.h, LUNCH_START.m);
      if (end <= morningStart) break;
      if (current < morningStart) current = morningStart;
      let ms = Math.min(end, morningEnd) - current;
      if (ms > 0) totalMs += ms;
      current = morningEnd;

      // Afternoon session
      let afternoonStart = setTime(current, LUNCH_END.h, LUNCH_END.m);
      let afternoonEnd = setTime(current, WORK_END.h, WORK_END.m);
      if (end <= afternoonStart) break;
      if (current < afternoonStart) current = afternoonStart;
      ms = Math.min(end, afternoonEnd) - current;
      if (ms > 0) totalMs += ms;
      current = afternoonEnd;
    }
    // Move to next day
    current = setTime(new Date(current.getFullYear(), current.getMonth(), current.getDate() + 1), WORK_START.h, WORK_START.m);
  }

  // Convert ms to HH:mm:ss
  const totalSeconds = Math.floor(totalMs / 1000);
  const h = Math.floor(totalSeconds / 3600);
  const m = Math.floor((totalSeconds % 3600) / 60);
  const s = totalSeconds % 60;
  return `${h}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
}

function isWorkingDay(date) {
  const day = date.getDay();
  // Sunday = 0, Saturday = 6
  return day >= 1 && day <= 6;
}

function setTime(date, h, m) {
  return new Date(date.getFullYear(), date.getMonth(), date.getDate(), h, m, 0, 0);
}

function normalize(str) {
  return (str || '').toString().trim().toLowerCase();
}
